# 2.3 从文本到数字

上一节我们确定了训练用的数据，大量输入输出文本的集合。

但文本是用来给人看的，而计算机中存储的都是数字。要想让计算机能够读懂文本，就需要先把它转换成数字。

最简单的转换是给每个字编一个序号，字和序号一一对应。这类似于一个字典，只要字典里面包含了所有可能出现的字，那么任何一句话就可以顺利地转译为一串数字。

在我们的案例中，为了节约空间，我并不打算用一个包含所有汉字的字典，而是用一个更小的字典，里面只包含训练数据中出现过的字。毕竟，历史上的所有古诗基本上涵盖了大部分写诗所需的字，用这些就够了。根据我的统计，训练数据中共出现了8548个不同的字，把他们按照出现的频率列出来大概长这样：

> 不，人，山，一，日，無，風，中，上，有，...(此处省略8528个字)，寗，犗，媍，璡，绵，靧，輣，儚，躒，銚

最热门的10个字大家都认识，但最冷门的10个字恐怕少有人能念得出来。

于是，我们可以直接根据这个字典，按照顺序给每个字赋予唯一的编号，从0直到8547。字的排序其实并不重要，无论是按频率排序还是随机排都没有关系，因为这一步只是给它们一个代号，并不会影响它们在后续环节的发挥。在我们的代码中，字是随机排序的。

把这个字典应用到上节的数据上，我们就拥有了一个用数字表示的输入输出的集合。举个例子，假设其中有两条数据长这样：

> **Input1**: 白日依山盡，黃河入海
>
> **Output1**: 流
>
> **Input2**: 無端五十絃，一絃一柱思華年。
>
> 莊生曉夢迷蝴蝶，望帝春心
>
> **Output2**: 託

把它们编码后就变成了这样：

> **Input1**: \[4403, 2704, 345, 1642, 4450, 8347, 8252, 3407, 536, 3503]
>
> **Output1**: 3486
>
> **Input2**: \[3875, 4861, 234, 749, 5129, 8347, 178, 5129, 178, 2952, 2048, 5823, 1846, 20, 2, 5782, 4276, 2803, 1307, 6978, 6170, 6171, 8347, 2844, 1807, 2732, 2009]
>
> **Output2**: 6436

如果你数一数文本和数字的个数，会发现它们是一一对应的。

现在，训练数据终于就绪了。我们可以进入下一步也是最重要的环节——搭建AI模型。
